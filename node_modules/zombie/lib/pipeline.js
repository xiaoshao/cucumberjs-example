'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _core = require('babel-runtime/core-js')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _ = require('lodash');
var assert = require('assert');
var DOM = require('./dom');
var Fetch = require('./fetch');
var File = require('fs');

var _require = require('./fetch');

var Headers = _require.Headers;

var _require2 = require('util');

var isArray = _require2.isArray;

var Path = require('path');
var Request = require('request');
var URL = require('url');
var Utils = require('jsdom/lib/jsdom/utils');

// Pipeline is sequence of request/response handlers that are used to prepare a
// request, make the request, and process the response.

var Pipeline = (function (_Array) {
  function Pipeline(browser) {
    _classCallCheck(this, Pipeline);

    _Array.call(this);
    this._browser = browser;
    for (var _iterator = Pipeline._default, _isArray = _core.Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var handler = _ref;

      this.push(handler);
    }
  }

  _inherits(Pipeline, _Array);

  Pipeline.prototype._fetch = function _fetch(input, init) {
    var request, browser, response;
    return _regeneratorRuntime.async(function _fetch$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          request = new Fetch.Request(input, init);
          browser = this._browser;

          browser.emit('request', request);

          context$2$0.prev = 3;
          context$2$0.next = 6;
          return this._runPipeline(request);

        case 6:
          response = context$2$0.sent;

          response.time = _core.Date.now();
          response.request = request;
          browser.emit('response', request, response);
          return context$2$0.abrupt('return', response);

        case 13:
          context$2$0.prev = 13;
          context$2$0.t2 = context$2$0['catch'](3);

          browser._debug('Resource error', context$2$0.t2.stack);
          throw new TypeError(context$2$0.t2.message);

        case 17:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this, [[3, 13]]);
  };

  Pipeline.prototype._runPipeline = function _runPipeline(request) {
    var browser, requestHandlers, responseHandlers, response, _iterator2, _isArray2, _i2, _ref2, requestHandler, _iterator3, _isArray3, _i3, _ref3, responseHandler;

    return _regeneratorRuntime.async(function _runPipeline$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          browser = this._browser;
          requestHandlers = this.filter(function (fn) {
            return fn.length === 2;
          }).concat(Pipeline.makeHTTPRequest);
          responseHandlers = this.filter(function (fn) {
            return fn.length === 3;
          });
          response = undefined;
          _iterator2 = requestHandlers, _isArray2 = _core.Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _core.getIterator(_iterator2);

        case 5:
          if (!_isArray2) {
            context$2$0.next = 11;
            break;
          }

          if (!(_i2 >= _iterator2.length)) {
            context$2$0.next = 8;
            break;
          }

          return context$2$0.abrupt('break', 23);

        case 8:
          _ref2 = _iterator2[_i2++];
          context$2$0.next = 15;
          break;

        case 11:
          _i2 = _iterator2.next();

          if (!_i2.done) {
            context$2$0.next = 14;
            break;
          }

          return context$2$0.abrupt('break', 23);

        case 14:
          _ref2 = _i2.value;

        case 15:
          requestHandler = _ref2;
          context$2$0.next = 18;
          return requestHandler(browser, request);

        case 18:
          response = context$2$0.sent;

          if (!response) {
            context$2$0.next = 21;
            break;
          }

          return context$2$0.abrupt('break', 23);

        case 21:
          context$2$0.next = 5;
          break;

        case 23:
          _iterator3 = responseHandlers, _isArray3 = _core.Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _core.getIterator(_iterator3);

        case 24:
          if (!_isArray3) {
            context$2$0.next = 30;
            break;
          }

          if (!(_i3 >= _iterator3.length)) {
            context$2$0.next = 27;
            break;
          }

          return context$2$0.abrupt('break', 41);

        case 27:
          _ref3 = _iterator3[_i3++];
          context$2$0.next = 34;
          break;

        case 30:
          _i3 = _iterator3.next();

          if (!_i3.done) {
            context$2$0.next = 33;
            break;
          }

          return context$2$0.abrupt('break', 41);

        case 33:
          _ref3 = _i3.value;

        case 34:
          responseHandler = _ref3;
          context$2$0.next = 37;
          return responseHandler(browser, request, response);

        case 37:
          response = context$2$0.sent;

          assert(response, 'Response handler must return a response');

        case 39:
          context$2$0.next = 24;
          break;

        case 41:
          return context$2$0.abrupt('return', response);

        case 42:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  // -- Handlers --

  // Add a request or response handler.  This handler will only be used by this
  // pipeline instance (browser).

  Pipeline.prototype.addHandler = function addHandler(handler) {
    assert(handler.call, 'Handler must be a function');
    assert(handler.length === 2 || handler.length === 3, 'Handler function takes 2 (request handler) or 3 (reponse handler) arguments');
    this.push(handler);
  };

  // Add a request or response handler.  This handler will be used by any new
  // pipeline instance (browser).

  Pipeline.addHandler = function addHandler(handler) {
    assert(handler.call, 'Handler must be a function');
    assert(handler.length === 2 || handler.length === 3, 'Handler function takes 2 (request handler) or 3 (response handler) arguments');
    this._default.push(handler);
  };

  // -- Prepare request --

  // This handler normalizes the request URL.
  //
  // It turns relative URLs into absolute URLs based on the current document URL
  // or base element, or if no document open, based on browser.site property.

  Pipeline.normalizeURL = function normalizeURL(browser, request) {
    if (browser.document)
      // Resolve URL relative to document URL/base, or for new browser, using
      // Browser.site
      request.url = DOM.resourceLoader.resolve(browser.document, request.url);else request.url = Utils.resolveHref(browser.site || 'http://localhost', request.url);
  };

  // This handler mergers request headers.
  //
  // It combines headers provided in the request with custom headers defined by
  // the browser (user agent, authentication, etc).
  //
  // It also normalizes all headers by down-casing the header names.

  Pipeline.mergeHeaders = function mergeHeaders(browser, request) {
    if (browser.headers) _.each(browser.headers, function (value, name) {
      request.headers.append(name, browser.headers[name]);
    });
    if (!request.headers.has('User-Agent')) request.headers.set('User-Agent', browser.userAgent);

    // Always pass Host: from request URL

    var _URL$parse = URL.parse(request.url);

    var host = _URL$parse.host;

    request.headers.set('Host', host);

    // HTTP Basic authentication
    var authenticate = { host: host, username: null, password: null };
    browser.emit('authenticate', authenticate);
    var username = authenticate.username;
    var password = authenticate.password;

    if (username && password) {
      browser.log('Authenticating as ' + username + ':' + password);
      var base64 = new Buffer('' + username + ':' + password).toString('base64');
      request.headers.set('authorization', 'Basic ' + base64);
    }
  };

  // -- Retrieve actualy resource --

  // Used to perform HTTP request (also supports file: resources).  This is always
  // the last request handler.

  Pipeline.makeHTTPRequest = function makeHTTPRequest(browser, request) {
    var url, _URL$parse2, protocol, hostname, pathname, filename, exists, stream, _ret;

    return _regeneratorRuntime.async(function makeHTTPRequest$(context$2$0) {
      var _this = this;

      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          url = request.url;
          _URL$parse2 = URL.parse(url);
          protocol = _URL$parse2.protocol;
          hostname = _URL$parse2.hostname;
          pathname = _URL$parse2.pathname;

          if (!(protocol === 'file:')) {
            context$2$0.next = 18;
            break;
          }

          if (!(request.method !== 'GET')) {
            context$2$0.next = 8;
            break;
          }

          return context$2$0.abrupt('return', new Fetch.Response('', { url: url, status: 405 }));

        case 8:
          filename = Path.normalize(decodeURI(pathname));
          exists = File.existsSync(filename);

          if (!exists) {
            context$2$0.next = 15;
            break;
          }

          stream = File.createReadStream(filename);
          return context$2$0.abrupt('return', new Fetch.Response(stream, { url: url, status: 200 }));

        case 15:
          return context$2$0.abrupt('return', new Fetch.Response('', { url: url, status: 404 }));

        case 16:
          context$2$0.next = 23;
          break;

        case 18:
          context$2$0.next = 20;
          return (function callee$2$0() {
            var cookies, cookieHeader, buffer, httpRequest;
            return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
              while (1) switch (context$3$0.prev = context$3$0.next) {
                case 0:
                  cookies = browser.cookies;
                  cookieHeader = cookies.serialize(hostname, pathname);

                  if (cookieHeader) request.headers.append('Cookie', cookieHeader);

                  if (!/^GET|HEAD$/.test(request.method)) {
                    context$3$0.next = 7;
                    break;
                  }

                  context$3$0.t3 = null;
                  context$3$0.next = 10;
                  break;

                case 7:
                  context$3$0.next = 9;
                  return request._consume();

                case 9:
                  context$3$0.t3 = context$3$0.sent;

                case 10:
                  buffer = context$3$0.t3;
                  httpRequest = new Request({
                    method: request.method,
                    uri: request.url,
                    headers: request.headers.toObject(),
                    proxy: browser.proxy,
                    body: buffer,
                    jar: false,
                    followRedirect: false,
                    strictSSL: browser.strictSSL,
                    localAddress: browser.localAddress || 0
                  });
                  context$3$0.next = 14;
                  return new _core.Promise(function (resolve, reject) {
                    httpRequest.on('response', function (response) {
                      // Request returns an object where property name is header name,
                      // property value is either header value, or an array if header sent
                      // multiple times (e.g. `Set-Cookie`).
                      var arrayOfHeaders = _.reduce(response.headers, function (headers, value, name) {
                        if (isArray(value)) {
                          for (var _iterator4 = value, _isArray4 = _core.Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _core.getIterator(_iterator4);;) {
                            var _ref4;

                            if (_isArray4) {
                              if (_i4 >= _iterator4.length) break;
                              _ref4 = _iterator4[_i4++];
                            } else {
                              _i4 = _iterator4.next();
                              if (_i4.done) break;
                              _ref4 = _i4.value;
                            }

                            var item = _ref4;

                            headers.push([name, item]);
                          }
                        } else headers.push([name, value]);
                        return headers;
                      }, []);

                      resolve(new Fetch.Response(response, {
                        url: request.url,
                        status: response.statusCode,
                        headers: new Headers(arrayOfHeaders)
                      }));
                    }).on('error', reject);
                  });

                case 14:
                  context$3$0.t4 = context$3$0.sent;
                  return context$3$0.abrupt('return', {
                    v: context$3$0.t4
                  });

                case 16:
                case 'end':
                  return context$3$0.stop();
              }
            }, null, _this);
          })();

        case 20:
          _ret = context$2$0.sent;

          if (!(typeof _ret === 'object')) {
            context$2$0.next = 23;
            break;
          }

          return context$2$0.abrupt('return', _ret.v);

        case 23:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  // -- Handle response --

  Pipeline.handleHeaders = function handleHeaders(browser, request, response) {
    response.headers = new Headers(response.headers);
    return response;
  };

  Pipeline.handleCookies = function handleCookies(browser, request, response) {
    // Set cookies from response: call update() with array of headers

    var _URL$parse3 = URL.parse(request.url);

    var hostname = _URL$parse3.hostname;
    var pathname = _URL$parse3.pathname;

    var newCookies = response.headers.getAll('Set-Cookie');
    browser.cookies.update(newCookies, hostname, pathname);
    return response;
  };

  Pipeline.handleRedirect = function handleRedirect(browser, request, response) {
    var status, _location;

    return _regeneratorRuntime.async(function handleRedirect$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          status = response.status;

          if (!(status === 301 || status === 302 || status === 303 || status === 307 || status === 308)) {
            context$2$0.next = 19;
            break;
          }

          if (!(request.redirect === 'error')) {
            context$2$0.next = 4;
            break;
          }

          return context$2$0.abrupt('return', Fetch.Response.error());

        case 4:
          _location = response.headers.get('Location');

          if (!(_location === null)) {
            context$2$0.next = 7;
            break;
          }

          return context$2$0.abrupt('return', response);

        case 7:
          if (!(request._redirectCount >= 20)) {
            context$2$0.next = 9;
            break;
          }

          return context$2$0.abrupt('return', Fetch.Response.error());

        case 9:

          browser.emit('redirect', request, response, _location);
          ++request._redirectCount;
          if (status !== 307) {
            request.method = 'GET';
            request.headers['delete']('Content-Type');
            request.headers['delete']('Content-Length');
            request.headers['delete']('Content-Transfer-Encoding');
          }

          // This request is referer for next
          request.headers.set('Referer', request.url);
          request.url = Utils.resolveHref(request.url, _location);
          context$2$0.next = 16;
          return browser.pipeline._runPipeline(request);

        case 16:
          return context$2$0.abrupt('return', context$2$0.sent);

        case 19:
          return context$2$0.abrupt('return', response);

        case 20:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  return Pipeline;
})(Array);

// The default pipeline.  All new pipelines are instantiated with this set of
// handlers.
Pipeline._default = [Pipeline.normalizeURL, Pipeline.mergeHeaders, Pipeline.handleHeaders, Pipeline.handleCookies, Pipeline.handleRedirect];

module.exports = Pipeline;

// If the request is for a file:// descriptor, just open directly from the
// file system rather than getting node's http (which handles file://
// poorly) involved.

// We're going to use cookies later when recieving response.
//# sourceMappingURL=pipeline.js.map