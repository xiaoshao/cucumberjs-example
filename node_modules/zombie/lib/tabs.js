// Tab management.

'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _core = require('babel-runtime/core-js')['default'];

var _ = require('lodash');
var createHistory = require('./history');

module.exports = (function (_Array) {
  function Tabs(browser) {
    _classCallCheck(this, Tabs);

    _Array.call(this);
    this._current = null;
    this._browser = browser;
    this.length = 0;
    _core.Object.defineProperty(this, 'length', { enumerable: false, writable: true });
    _core.Object.defineProperty(this, '_browser', { enumerable: false, writable: true });
    _core.Object.defineProperty(this, '_current', { enumerable: false, writable: true });
  }

  _inherits(Tabs, _Array);

  // Returns window by index or name. Use this for window names that shadow
  // existing properties (e.g. tabs['open'] is a function, use

  Tabs.prototype.find = function find(nameOrWindow) {
    if (this.propertyIsEnumerable(nameOrWindow)) {
      return this[nameOrWindow];
    }var byName = _.find(this, { name: nameOrWindow });
    if (byName) {
      return byName;
    }if (this._indexOf(nameOrWindow) >= 0) {
      return nameOrWindow;
    }return null;
  };

  // Opens and returns a tab.  If an open window by the same name already exists,
  // opens this window in the same tab.  Omit name or use '_blank' to always open
  // a new tab.
  //
  // name    - Window name (optional)
  // opener  - Opening window (window.open call)
  // referer - Referrer
  // url     - Set document location to this URL upon opening
  // html    - Document contents (browser.load)

  Tabs.prototype.open = (function (_open) {
    function open() {
      return _open.apply(this, arguments);
    }

    open.toString = function () {
      return _open.toString();
    };

    return open;
  })(function () {
    var _this = this;

    var options = arguments[0] === undefined ? {} : arguments[0];

    // If name window in open tab, reuse that tab. Otherwise, open new window.
    var named = options.name && this.find(options.name.toString());
    if (named) {
      // Select this as the currenly open tab. Changing the location would then
      // select a different window.
      this._current = named;
      if (options.url) this._current.location = options.url;
      return this._current;
    }

    // When window changes we need to change tab slot. We can't keep the index
    // around, since tab order changes, so we look up the currently known
    // active window and switch that around.
    var active = null;
    var open = createHistory(this._browser, function (window) {
      // Focus changes to different window, make it the active window
      if (!Tabs.sameWindow(window, active)) {
        var index = _this._indexOf(active);
        if (index >= 0) _this[index] = window;
        _this.current = active = window;
      }
      if (window) _this._browser._eventLoop.setActiveWindow(window);
    });

    var name = options.name === '_blank' ? '' : options.name || '';
    options.name = name;
    var window = open(options);
    this.push(window);
    if (name && (this.propertyIsEnumerable(name) || !this[name])) this[name] = window;
    // Select this as the currenly open tab
    this.current = active = window;
    return window;
  });

  // Close an open tab.
  //
  // With no argument, closes the currently open tab (tabs.current).
  //
  // Argument can be the window, window name or tab position (same as find).

  Tabs.prototype.close = function close(nameOrWindow) {
    var window = nameOrWindow ? this.find(nameOrWindow) : this._current;
    if (this._indexOf(window) >= 0) window.close();
  };

  // Closes all open tabs/windows.

  Tabs.prototype.closeAll = function closeAll() {
    for (var _iterator = this.slice(), _isArray = _core.Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var tab = _ref;

      tab.close();
    }
  };

  // Dump list of all open tabs to stdout or output stream.

  Tabs.prototype.dump = function dump() {
    var output = arguments[0] === undefined ? process.stdout : arguments[0];

    if (this.length === 0) {
      output.write('No open tabs.\n');
      return;
    }
    for (var _iterator2 = this, _isArray2 = _core.Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _core.getIterator(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var tab = _ref2;

      output.write('Window ' + (tab.name || 'unnamed') + ' open to ' + tab.location.href + '\n');
    }
  };

  // Find the position of this window in the tabs array

  Tabs.prototype._indexOf = function _indexOf(window) {
    if (!window) {
      return -1;
    }return this.slice().map(function (tab) {
      return tab._globalProxy;
    }).indexOf(window._globalProxy);
  };

  // Called when window closed to remove it from tabs list.

  Tabs.prototype._closed = function _closed(window) {
    var index = this._indexOf(window);
    if (index >= 0) {
      this._browser.emit('inactive', window);

      this.splice(index, 1);
      if (this.propertyIsEnumerable(window.name)) delete this[window.name];

      // If we closed the currently open tab, need to select another window.
      if (Tabs.sameWindow(window, this._current)) {
        // Don't emit inactive event for closed window.
        this._current = this[index - 1] || this[0];
        if (this._current) this._browser.emit('active', this._current);
      }
    }
  };

  // Determine if two windows are the same

  Tabs.sameWindow = function sameWindow(a, b) {
    return a && b && a._globalProxy === b._globalProxy;
  };

  _createClass(Tabs, [{
    key: 'current',

    // Get the currently open tab
    get: function () {
      return this._current;
    },

    // Sets the currently open tab
    // - Name   - Pick existing window with this name
    // - Number - Pick existing window from tab position
    // - Window - Use this window
    set: function (nameOrWindow) {
      var window = this.find(nameOrWindow);
      if (this._indexOf(window) < 0) return;
      if (!Tabs.sameWindow(this._current, window)) {
        if (this._current) this._browser.emit('inactive', this._current);
        this._current = window;
        this._browser.emit('active', this._current);
      }
    }
  }, {
    key: 'index',

    // Index of currently selected tab.
    get: function () {
      return this._indexOf(this._current);
    }
  }]);

  return Tabs;
})(Array);
//# sourceMappingURL=tabs.js.map