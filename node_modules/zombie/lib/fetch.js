'use strict';

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _core = require('babel-runtime/core-js')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _ = require('lodash');
var HTTP = require('http');
var Promise = require('bluebird');
var Stream = require('stream');
var URL = require('url');
var Zlib = require('zlib');

// Decompress stream based on content and transfer encoding headers.
function decompressStream(stream, headers) {
  var transferEncoding = headers.get('Transfer-Encoding');
  var contentEncoding = headers.get('Content-Encoding');
  if (contentEncoding === 'deflate' || transferEncoding === 'deflate') {
    return stream.pipe(Zlib.createInflate());
  }if (contentEncoding === 'gzip' || transferEncoding === 'gzip') {
    return stream.pipe(Zlib.createGunzip());
  }return stream;
}

// https://fetch.spec.whatwg.org/#headers-class

var Headers = (function () {
  function Headers(init) {
    var _this = this;

    _classCallCheck(this, Headers);

    this._headers = [];
    if (init instanceof Headers) {
      for (var _iterator = init, _isArray = _core.Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.getIterator(_iterator);;) {
        var _ref;

        if (_isArray) {
          if (_i >= _iterator.length) break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done) break;
          _ref = _i.value;
        }

        var _name = _ref[0];
        var value = _ref[1];

        this.append(_name, value);
      }
    } else if (init instanceof Array) {
      for (var _iterator2 = init, _isArray2 = _core.Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _core.getIterator(_iterator2);;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var _name2 = _ref2[0];
        var value = _ref2[1];

        this.append(_name2, value);
      }
    } else if (init instanceof Object) _.each(init, function (value, name) {
      _this.append(name, value);
    });
  }

  Headers.prototype.append = function append(name, value) {
    var caseInsensitive = name.toLowerCase();
    var castValue = String(value).replace(/\r\n/g, '');
    this._headers.push([caseInsensitive, castValue]);
  };

  Headers.prototype['delete'] = function _delete(name) {
    var caseInsensitive = name.toLowerCase();
    this._headers = this._headers.filter(function (header) {
      return header[0] !== caseInsensitive;
    });
  };

  Headers.prototype.get = function get(name) {
    var caseInsensitive = name.toLowerCase();
    var header = _.find(this._headers, function (header) {
      return header[0] === caseInsensitive;
    });
    return header ? header[1] : null;
  };

  Headers.prototype.getAll = function getAll(name) {
    var caseInsensitive = name.toLowerCase();
    return this._headers.filter(function (header) {
      return header[0] === caseInsensitive;
    }).map(function (header) {
      return header[1];
    });
  };

  Headers.prototype.has = function has(name) {
    var caseInsensitive = name.toLowerCase();
    var header = _.find(this._headers, function (header) {
      return header[0] === caseInsensitive;
    });
    return !!header;
  };

  Headers.prototype.set = function set(name, value) {
    var caseInsensitive = name.toLowerCase();
    var castValue = String(value).replace(/\r\n/g, '');
    var replaced = false;
    this._headers = this._headers.reduce(function (headers, _ref4) {
      var name = _ref4[0];
      var value = _ref4[1];

      if (name !== caseInsensitive) headers.push([name, value]);else if (!replaced) {
        headers.push([name, castValue]);
        replaced = true;
      }
      return headers;
    }, []);

    if (!replaced) this.append(name, value);
  };

  Headers.prototype[_core.Symbol.iterator] = function () {
    return _core.getIterator(this._headers);
  };

  Headers.prototype.valueOf = function valueOf() {
    return this._headers.map(function (_ref5) {
      var name = _ref5[0];
      var value = _ref5[1];
      return '' + name + ': ' + value;
    });
  };

  Headers.prototype.toString = function toString() {
    return this.valueOf().join('\n');
  };

  Headers.prototype.toObject = function toObject() {
    var object = _core.Object.create(null);
    for (var _iterator3 = this._headers, _isArray3 = _core.Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _core.getIterator(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var _name3 = _ref3[0];
      var value = _ref3[1];

      object[_name3] = value;
    }return object;
  };

  return Headers;
})();

var FormData = (function () {
  function FormData() {
    _classCallCheck(this, FormData);

    this._entries = [];
  }

  FormData.prototype.append = function append(name, value, filename) {
    // TODO add support for files
    this._entries.push([name, value]);
  };

  FormData.prototype.set = function set(name, value, filename) {
    this['delete'](name);
    this.append(name, value, filename);
  };

  FormData.prototype['delete'] = function _delete(name) {
    this._entries = this._entries.filter(function (entry) {
      return entry[0] !== name;
    });
  };

  FormData.prototype.get = function get(name) {
    var entry = _.find(this._entries, function (entry) {
      return entry[0] === name;
    });
    return entry ? entry[1] : null;
  };

  FormData.prototype.getAll = function getAll(name) {
    return this._entries.filter(function (entry) {
      return entry[0] === name;
    }).map(function (entry) {
      return entry[1];
    });
  };

  FormData.prototype.has = function has(name) {
    var entry = _.find(this._entries, function (entry) {
      return entry[0] === name;
    });
    return !!entry;
  };

  FormData.prototype[_core.Symbol.iterator] = function () {
    return _core.getIterator(this._entries);
  };

  FormData.prototype._asStream = function _asStream(boundary) {
    var iterator = _core.getIterator(this._entries);
    var stream = new Stream.Readable();
    stream._read = function () {
      var next = iterator.next();
      if (next.value) {
        var _next$value = next.value;
        var _name4 = _next$value[0];
        var value = _next$value[1];

        this.push('--' + boundary + '\r\n');
        if (value.read) {
          var buffer = value.read();
          this.push('Content-Disposition: form-data; name="' + _name4 + '"; filename="' + value + '"\r\n');
          this.push('Content-Type: ' + (value.mime || 'application/octet-stream') + '\r\n');
          this.push('Content-Length: ' + buffer.length + '\r\n\r\n');
          this.push(buffer);
        } else {
          var text = value.toString('utf-8');
          this.push('Content-Disposition: form-data; name="' + _name4 + '"\r\n');
          this.push('Content-Type: text/plain; charset=utf8\r\n\r\n');
          this.push('Content-Length: ' + text.length + '\r\n\r\n');
          this.push(text);
        }
        this.push('\r\n');
      }
      if (next.done) {
        this.push('--' + boundary + '--');
        this.push(null);
      }
    };
    return stream;
  };

  _createClass(FormData, [{
    key: 'length',
    get: function () {
      return this._entries.length;
    }
  }]);

  return FormData;
})();

var Body = (function () {
  function Body(bodyInit) {
    _classCallCheck(this, Body);

    if (bodyInit instanceof Body) {
      this._stream = bodyInit._stream;
      this._contentType = bodyInit.headers.get('Content-Type');
    } else if (bodyInit instanceof Stream.Readable) {
      // Request + Replay start streaming immediately, so we need this trick to
      // buffer HTTP responses; this is likely a bug in Replay
      this._stream = new Stream.PassThrough();
      this._stream.pause();
      bodyInit.pipe(this._stream);
    } else if (typeof bodyInit === 'string' || bodyInit instanceof String) {
      this._stream = new Stream.Readable();
      this._stream._read = function () {
        this.push(bodyInit);
        this.push(null);
      };
      this._contentType = 'text/plain;charset=UTF-8';
    } else if (bodyInit instanceof FormData && bodyInit.length) {
      var boundary = '' + new Date().getTime() + '.' + Math.random();
      this._contentType = 'multipart/form-data;boundary=' + boundary;
      this._stream = bodyInit._asStream(boundary);
    } else if (bodyInit instanceof FormData) this._contentType = 'text/plain;charset=UTF-8';else if (bodyInit) throw new TypeError('This body type not yet supported');

    this._bodyUsed = false;
    this.body = null;
  }

  Body.prototype.arrayBuffer = (function (_arrayBuffer) {
    function arrayBuffer() {
      return _arrayBuffer.apply(this, arguments);
    }

    arrayBuffer.toString = function () {
      return _arrayBuffer.toString();
    };

    return arrayBuffer;
  })(function callee$1$0() {
    var arrayBuffer, i;
    return _regeneratorRuntime.async(function callee$1$0$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return this._consume();

        case 2:
          this.body = context$2$0.sent;
          arrayBuffer = new Uint8Array(this.body.length);

          for (i = 0; i < this.body.length; ++i) {
            arrayBuffer[i] = this.body[i];
          }return context$2$0.abrupt('return', arrayBuffer);

        case 6:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  });

  Body.prototype.blob = function blob() {
    return _regeneratorRuntime.async(function blob$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          throw new Error('Not implemented yet');

        case 1:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  Body.prototype.formData = function formData() {
    var buffer, contentType, mimeType;
    return _regeneratorRuntime.async(function formData$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return this._consume();

        case 2:
          buffer = context$2$0.sent;
          contentType = this.headers.get('Content-Type') || '';
          mimeType = contentType.split(';')[0];
          context$2$0.t1 = mimeType;
          context$2$0.next = context$2$0.t1 === 'multipart/form-data' ? 8 : context$2$0.t1 === 'application/x-www-form-urlencoded' ? 9 : 10;
          break;

        case 8:
          throw new Error('Not implemented yet');

        case 9:
          throw new Error('Not implemented yet');

        case 10:
          throw new TypeError('formData does not support MIME type ' + mimeType);

        case 11:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  Body.prototype.json = function json() {
    var buffer;
    return _regeneratorRuntime.async(function json$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return this._consume();

        case 2:
          buffer = context$2$0.sent;

          this.body = buffer.toString('utf-8');
          return context$2$0.abrupt('return', JSON.parse(this.body));

        case 5:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  Body.prototype.text = function text() {
    var buffer;
    return _regeneratorRuntime.async(function text$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          context$2$0.next = 2;
          return this._consume();

        case 2:
          buffer = context$2$0.sent;

          this.body = buffer.toString();
          return context$2$0.abrupt('return', this.body);

        case 5:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  // -- Implementation details --

  Body.prototype._consume = function _consume() {
    var decompressed;
    return _regeneratorRuntime.async(function _consume$(context$2$0) {
      while (1) switch (context$2$0.prev = context$2$0.next) {
        case 0:
          if (!this._bodyUsed) {
            context$2$0.next = 2;
            break;
          }

          throw new TypeError('Body already consumed');

        case 2:
          this._bodyUsed = true;

          if (this._stream) {
            context$2$0.next = 5;
            break;
          }

          return context$2$0.abrupt('return', null);

        case 5:
          if (this._stream.readable) {
            context$2$0.next = 7;
            break;
          }

          return context$2$0.abrupt('return', new Buffer(''));

        case 7:
          decompressed = decompressStream(this._stream, this.headers);
          context$2$0.next = 10;
          return new Promise(function (resolve) {
            var buffers = [];
            decompressed.on('data', function (buffer) {
              buffers.push(buffer);
            }).on('end', function () {
              resolve(Buffer.concat(buffers));
            }).on('error', function () {
              resolve(Buffer.concat(buffers));
            }).resume();
          });

        case 10:
          return context$2$0.abrupt('return', context$2$0.sent);

        case 11:
        case 'end':
          return context$2$0.stop();
      }
    }, null, this);
  };

  _createClass(Body, [{
    key: 'bodyUsed',
    get: function () {
      return this._bodyUsed;
    }
  }]);

  return Body;
})();

// https://fetch.spec.whatwg.org/#request-class

var Request = (function (_Body) {
  function Request(input, init) {
    _classCallCheck(this, Request);

    var method = ((init ? init.method : input.method) || 'GET').toUpperCase();
    var bodyInit = null;

    if (input instanceof Request && input._stream) {
      if (input._bodyUsed) throw new TypeError('Request body already used');
      bodyInit = input;
      input._bodyUsed = true;
    }

    if (init && init.body) {
      if (method === 'GET' || method === 'HEAD') throw new TypeError('Cannot include body with GET/HEAD request');
      bodyInit = init.body;
    }
    _Body.call(this, bodyInit);

    if (typeof input === 'string' || input instanceof String) this.url = URL.format(input);else if (input instanceof Request) this.url = input.url;
    if (!this.url) throw new TypeError('Input must be string or another Request');

    this.method = method;
    this.headers = new Headers(init ? init.headers : input.headers);
    if (this._contentType && !this.headers.has('Content-Type')) this.headers.set('Content-Type', this._contentType);

    // Default redirect is follow, also treat manual as follow
    this.redirect = init && init.redirect;
    if (this.redirect !== 'error') this.redirect = 'follow';
    this._redirectCount = 0;
  }

  _inherits(Request, _Body);

  // -- From Request interface --

  Request.prototype.clone = function clone() {
    if (this._bodyUsed) throw new TypeError('This Request body has already been used');
    throw new Error('Not implemented yet');
  }

  // -- From Body interface --

  ;

  return Request;
})(Body);

// https://fetch.spec.whatwg.org/#response-class

var Response = (function (_Body2) {
  function Response(bodyInit, responseInit) {
    _classCallCheck(this, Response);

    _Body2.call(this, bodyInit);
    if (responseInit) {
      if (responseInit.status < 200 || responseInit.status > 599) throw new RangeError('Status code ' + responseInit.status + ' not in range');
      var statusText = responseInit.statusText || HTTP.STATUS_CODES[responseInit.status] || 'Unknown';
      if (!/^[^\n\r]+$/.test(statusText)) throw new TypeError('Status text ' + responseInit.statusText + ' not valid format');

      this._url = URL.format(responseInit.url || '');
      this.type = 'default';
      this.status = responseInit.status;
      this.statusText = statusText;
      this.headers = new Headers(responseInit.headers);
    } else {
      this.type = 'error';
      this.status = 0;
      this.statusText = '';
      this.headers = new Headers();
    }
    if (this._contentType && !this.headers.has('Content-Type')) this.headers.set('Content-Type', this._contentType);
  }

  _inherits(Response, _Body2);

  Response.prototype.clone = function clone() {
    if (this._bodyUsed) throw new TypeError('This Response body has already been used');
    throw new Error('Not implemented yet');
  };

  Response.error = function error() {
    return new Response();
  };

  Response.redirect = function redirect(url) {
    var status = arguments[1] === undefined ? 302 : arguments[1];

    var parsedURL = URL.parse(url);
    if ([301, 302, 303, 307, 308].indexOf(status) < 0) throw new RangeError('Status code ' + status + ' not valid redirect code');
    var statusText = HTTP.STATUS_CODES[status];
    var response = new Response(null, { status: status, statusText: statusText });
    response.headers.set('Location', URL.format(parsedURL));
    return response;
  };

  _createClass(Response, [{
    key: 'url',
    get: function () {
      return (this._url || '').split('#')[0];
    }
  }, {
    key: 'ok',
    get: function () {
      return this.status >= 200 && this.status <= 299;
    }
  }]);

  return Response;
})(Body);

module.exports = {
  Headers: Headers,
  FormData: FormData,
  Request: Request,
  Response: Response
};
// When Request has no body, _stream is typically null

// When Response has no body, we get stream that's no longer readable
//# sourceMappingURL=fetch.js.map