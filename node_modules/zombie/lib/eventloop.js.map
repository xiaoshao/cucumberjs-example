{"version":3,"sources":["eventloop.js"],"names":[],"mappings":"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","file":"eventloop.js","sourcesContent":["// The event loop.\n//\n// Each browser has an event loop, which processes asynchronous events like\n// loading pages and resources, XHR, timeouts and intervals, etc. These are\n// procesed in order.\n//\n// The purpose of the event loop is two fold:\n// - To get events processed in the right order for the active window (and only\n//   the active window)\n// - And to allow the code to wait until all events have been processed\n//   (browser.wait, .visit, .pressButton, etc)\n//\n// The event loop has one interesting method: `wait`.\n//\n// Each window maintains its own event queue. Its interesting methods are\n// `enqueue`, `http`, `dispatch` and the timeout/interval methods.\n\n\nconst assert            = require('assert');\nconst { EventEmitter }  = require('events');\n\n\n// Wrapper for a timeout (setTimeout)\nclass Timeout {\n\n  // eventQueue - Reference to the event queue\n  // fn         - When timer fires, evaluate this function\n  // delay      - How long to wait\n  // remove     - Call this to discard timer\n  //\n  // Instance variables add:\n  // handle  - Node.js timeout handle\n  // next    - When is this timer firing next\n  constructor(eventQueue, fn, delay, remove) {\n    this.eventQueue   = eventQueue;\n    this.fn           = fn;\n    this.delay        = Math.max(delay || 0, 0);\n    this.remove       = remove;\n\n    this.handle       = global.setTimeout(this.fire.bind(this), this.delay);\n    this.next         = Date.now() + this.delay;\n  }\n\n  fire() {\n    // In response to Node firing setTimeout, but only allowed to process this\n    // event during a wait()\n    this.eventQueue.enqueue(()=> {\n      const { eventLoop } = this.eventQueue;\n      eventLoop.emit('setTimeout', this.fn, this.delay);\n      try {\n        this.eventQueue.window._evaluate(this.fn);\n      } catch (error) {\n        eventLoop.emit('error', error);\n      }\n    });\n    this.remove();\n  }\n\n  // clearTimeout\n  stop() {\n    global.clearTimeout(this.handle);\n    this.remove();\n  }\n\n}\n\n\n// Wapper for an interval (setInterval)\nclass Interval {\n\n  // eventQueue - Reference to the event queue\n  // fn        - When timer fires, evaluate this function\n  // interval  - Interval between firing\n  // remove    - Call this to discard timer\n  //\n  // Instance variables add:\n  // handle  - Node.js interval handle\n  // next    - When is this timer firing next\n  constructor(eventQueue, fn, interval, remove) {\n    this.eventQueue     = eventQueue;\n    this.fn             = fn;\n    this.interval       = Math.max(interval || 0, 0);\n    this.remove         = remove;\n    this.fireInProgress = false;\n    this.handle         = global.setInterval(this.fire.bind(this), this.interval);\n    this.next           = Date.now() + this.interval;\n  }\n\n  fire() {\n    // In response to Node firing setInterval, but only allowed to process this\n    // event during a wait()\n    this.next = Date.now() + this.interval;\n\n    // setInterval events not allowed to overlap, don't queue two at once\n    if (this.fireInProgress)\n      return;\n    this.fireInProgress = true;\n    this.eventQueue.enqueue(()=> {\n      this.fireInProgress = false;\n\n      const { eventLoop } = this.eventQueue;\n      eventLoop.emit('setInterval', this.fn, this.interval);\n      try {\n        this.eventQueue.window._evaluate(this.fn);\n      } catch (error) {\n        eventLoop.emit('error', error);\n      }\n    });\n  }\n\n  // clearTimeout\n  stop() {\n    global.clearInterval(this.handle);\n    this.remove();\n  }\n\n}\n\n\n// Each window has an event queue that holds all pending events.  Various\n// browser features push new functions into the queue (e.g. process XHR\n// response, setTimeout fires).  The event loop is responsible to pop these\n// events from the queue and run them, but only during browser.wait().\n//\n// In addition, the event queue keeps track of all outstanding timers\n// (setTimeout/setInterval) so it can return consecutive handles and clean them\n// up during window.destroy().\n//\n// In addition, we keep track of when the browser is expecting an event to\n// arrive in the queue (e.g. sent XHR request, expecting an event to process the\n// response soon enough).  The event loop uses that to determine if it's worth\n// waiting.\nclass EventQueue {\n\n  // Instance variables:\n  // browser          - Reference to the browser\n  // eventLoop        - Reference to the browser's event loop\n  // queue            - FIFO queue of functions to call\n  // expecting        - These are holding back the event loop\n  // timers           - Sparse array of timers (index is the timer handle)\n  // eventSources     - Additional sources for events (SSE, WS, etc)\n  // nextTimerHandle  - Value of next timer handler\n  constructor(window) {\n    this.window           = window;\n    this.browser          = window.browser;\n    this.eventLoop        = this.browser._eventLoop;\n    this.queue            = [];\n    this.expecting        = 0;\n    this.timers           = [];\n    this.eventSources     = [];\n    this.nextTimerHandle  = 1;\n  }\n\n\n  // Cleanup when we dispose of the window\n  destroy() {\n    if (!this.queue)\n      return;\n    this.queue = null;\n\n    for (let timer of this.timers) {\n      if (timer)\n        timer.stop();\n    }\n    this.timers = null;\n\n    for (let eventSource of this.eventSources) {\n      //if (eventSource)\n        eventSource.close();\n    }\n    this.eventSources = null;\n  }\n\n\n  // -- Events --\n\n  // Any events expected in the future?\n  get expected() {\n    return !!(this.expecting ||\n              [...this.window.frames].filter(frame => frame._eventQueue.expected).length);\n  }\n\n  // Add a function to the event queue, to be executed in order.\n  enqueue(fn) {\n    assert(this.queue, 'This browser has been destroyed');\n    assert(typeof fn === 'function', 'eventLoop.enqueue called without a function');\n\n    if (fn) {\n      this.queue.push(fn);\n      this.eventLoop.run();\n    }\n  }\n\n\n  // Event loop uses this to grab event from top of the queue.\n  dequeue() {\n    assert(this.queue, 'This browser has been destroyed');\n\n    const fn = this.queue.shift();\n    if (fn)\n      return fn;\n    for (let frame of [...this.window.frames]) {\n      let childFn = frame._eventQueue.dequeue();\n      if (childFn)\n        return childFn;\n    }\n    return null;\n  }\n\n\n  // Makes an HTTP request.\n  //\n  // Parameters are:\n  // method   - Method (defaults to GET)\n  // url      - URL (string)\n  // options  - See below\n  // callback - Called with error, or null and response\n  //\n  // Options:\n  //   headers   - Name/value pairs of headers to send in request\n  //   params    - Parameters to pass in query string or document body\n  //   body      - Request document body\n  //   timeout   - Request timeout in milliseconds (0 or null for no timeout)\n  //\n  // Calls callback with response error or null and response object.\n  http(method, url, options, callback) {\n    assert(this.queue, 'This browser has been destroyed');\n\n    // We're expecting to queue an event, event loop should wait\n    ++this.expecting;\n    this.browser.resources.request(method, url, options, (error, response)=> {\n      --this.expecting;\n      // We can't cancel pending requests, but we can ignore the response if\n      // window already closed\n      if (this.queue)\n        // This will get completion function to execute, e.g. to check a page\n        // before meta tag refresh\n        this.enqueue(()=> {\n          callback(error, response);\n        });\n    });\n  }\n\n  // Fire an error event.  Used by JSDOM patches.\n  onerror(error) {\n    assert(this.queue, 'This browser has been destroyed');\n\n    this.eventLoop.emit('error', error);\n\n    const event = this.window.document.createEvent('Event');\n    event.initEvent('error', false, false);\n    event.message = error.message;\n    event.error = error;\n    this.window.dispatchEvent(event);\n  }\n\n\n  // -- EventSource --\n\n  addEventSource(eventSource) {\n    assert(this.queue, 'This browser has been destroyed');\n\n    this.eventSources.push(eventSource);\n\n    const emit = eventSource.emit;\n    eventSource.emit = (...args)=> {\n      this.eventLoop.emit('serverEvent');\n      this.enqueue(()=> {\n        emit.apply(eventSource, args);\n      });\n    };\n  }\n\n\n  // -- Timers --\n\n  // Window.setTimeout\n  setTimeout(fn, delay = 0) {\n    assert(this.queue, 'This browser has been destroyed');\n    if (!fn)\n      return null;\n\n    const handle = this.nextTimerHandle;\n    ++this.nextTimerHandle;\n    this.timers[handle] = new Timeout(this, fn, delay, ()=> {\n      delete this.timers[handle];\n    });\n    return handle;\n  }\n\n  // Window.clearTimeout\n  clearTimeout(handle) {\n    assert(this.queue, 'This browser has been destroyed');\n\n    const timer = this.timers[handle];\n    if (timer)\n      timer.stop();\n  }\n\n  // Window.setInterval\n  setInterval(fn, interval = 0) {\n    assert(this.queue, 'This browser has been destroyed');\n    if (!fn)\n      return null;\n\n    const handle = this.nextTimerHandle;\n    ++this.nextTimerHandle;\n    this.timers[handle] = new Interval(this, fn, interval, ()=> {\n      delete this.timers[handle];\n    });\n    return handle;\n  }\n\n  // Window.clearInterval\n  clearInterval(handle) {\n    assert(this.queue, 'This browser has been destroyed');\n\n    const timer = this.timers[handle];\n    if (timer)\n      timer.stop();\n  }\n\n  // Returns the timestamp of the next timer event\n  get next() {\n    const timers  = this.timers.map(timer => timer.next);\n    const frames  = [...this.window.frames].map(frame => frame._eventQueue.next);\n    return timers.concat(frames).sort()[0] || Infinity;\n  }\n\n}\n\n\n// The browser event loop.\n//\n// Each browser has one event loop that processes events from the queues of the\n// currently active window and its frames (child windows).\n//\n// The wait method is responsible to process all pending events.  It goes idle\n// once:\n// - There are no more events waiting in the queue (of the active window)\n// - There are no more timers waiting to fire (next -> Infinity)\n// - No future events are expected to arrive (e.g. in-progress XHR requests)\n//\n// The wait method will complete before the loop goes idle, if:\n// - Past the specified timeout\n// - The next scheduled timer is past the specified timeout\n// - The completio function evaluated to true\n//\n// While processing, the event loop emits the following events (on the browser\n// object):\n// tick(next) - Emitted after executing a single event; the argument is the\n//              expected duration until the next event (in ms)\n// idle       - Emitted when there are no more events (queued or expected)\n// error(err) - Emitted after an error\nmodule.exports = class EventLoop extends EventEmitter {\n\n  // Instance variables are:\n  // active    - Currently active window\n  // browser   - Reference to the browser\n  // running   - True when inside a run loop\n  // waiting   - Counts in-progess calls to wait (waiters?)\n  constructor(browser) {\n    this.browser  = browser;\n    this.active   = null;\n    this.running  = false;\n    this.waiting  = 0;\n  }\n\n\n  // -- The wait function --\n\n  // Wait until one of these happen:\n  // 1. We run out of events to process; callback is called with null and false\n  // 2. The completion function evaluates to true; callback is called with null\n  //    and false\n  // 3. The time duration elapsed; callback is called with null and true\n  // 2. An error occurs; callback is called with an error\n  //\n  // Duration is specifies in milliseconds or string form (e.g. \"15s\").\n  //\n  // Completion function is called with the currently active window (may change\n  // during page navigation or form submission) and how long until the next\n  // event, and returns true to stop waiting, any other value to continue\n  // processing events.\n  //\n  //\n  // waitDuration       - How long to wait (ms)\n  // completionFunction - Returns true for early completion\n  wait(waitDuration, completionFunction, callback) {\n    assert(waitDuration, 'Wait duration required, cannot be 0');\n    const eventLoop = this;\n\n    ++eventLoop.waiting;\n    // Someone (us) just started paying attention, start processing events\n    if (eventLoop.waiting === 1)\n      setImmediate(()=> eventLoop.run());\n\n    // The timer fires when we waited long enough, we need timeoutOn to tell if\n    // the next event is past the wait duration and there's no point in waiting\n    // further\n    const timer     = global.setTimeout(timeout, waitDuration);\n    const timeoutOn = Date.now() + waitDuration;\n\n    // Fired after every event, decide if we want to stop waiting\n    function ontick(next) {\n      // No point in waiting that long\n      if (next >= timeoutOn) {\n        timeout();\n        return;\n      }\n\n      const activeWindow = eventLoop.active;\n      if (completionFunction && activeWindow.document.documentElement)\n        try {\n          const waitFor   = Math.max(next - Date.now(), 0);\n          // Event processed, are we ready to complete?\n          const completed = completionFunction(activeWindow, waitFor);\n          if (completed)\n            done();\n        } catch (error) {\n          done(error);\n        }\n\n    }\n\n    // The wait is over ...\n    function done(error) {\n      global.clearTimeout(timer);\n      eventLoop.removeListener('tick', ontick);\n      eventLoop.removeListener('idle', done);\n      eventLoop.browser.removeListener('error', done);\n\n      --eventLoop.waiting;\n      callback(error);\n    }\n\n    // We gave up, could be result of slow response ...\n    function timeout() {\n      if (eventLoop.expected)\n        done(new Error('Timeout: did not get to load all resources on this page'));\n      else\n        done();\n    }\n\n    eventLoop.on('tick', ontick);\n\n    // Fired when there are no more events to process\n    eventLoop.once('idle', done);\n\n    // Stop on first error reported (document load, script, etc)\n    // Event loop errors also propagated to the browser\n    eventLoop.browser.once('error', done);\n  }\n\n\n  dump(output = process.stdout) {\n    if (this.running)\n      output.write('Event loop: running\\n');\n    else if (this.expected)\n      output.write(`Event loop: waiting for ${this.expected} events\\n`);\n    else if (this.waiting)\n      output.write('Event loop: waiting\\n');\n    else\n      output.write('Event loop: idle\\n');\n  }\n\n\n  // -- Event queue management --\n\n  // Creates and returns a new event queue (see EventQueue).\n  createEventQueue(window) {\n    return new EventQueue(window);\n  }\n\n  // Set the active window. Suspends processing events from any other window, and\n  // switches to processing events from this window's queue.\n  setActiveWindow(window) {\n    if (window === this.active)\n      return;\n    this.active = window;\n    this.run(); // new window, new events?\n  }\n\n  // Are there any expected events for the active window?\n  get expected() {\n    return this.active && this.active._eventQueue.expected;\n  }\n\n\n  // -- Event processing --\n\n  // Grabs next event from the queue, processes it and notifies all listeners.\n  // Keeps processing until the queue is empty or all listeners are gone. You\n  // only need to bootstrap this when you suspect it's not recursing.\n  run() {\n    // A lot of code calls run() without checking first, so not uncommon to have\n    // concurrent executions of this function\n    if (this.running)\n      return;\n    // Is there anybody out there?\n    if (this.waiting === 0)\n      return;\n\n    // Give other (Node) events a chance to process\n    this.running = true;\n    setImmediate(()=> {\n      this.running = false;\n      try {\n\n        // Are there any open windows?\n        if (!this.active) {\n          this.emit('idle');\n          return;\n        }\n        // Don't run event outside browser.wait()\n        if (this.waiting === 0)\n          return;\n\n        const jsdomQueue  = this.active.document._queue;\n        const event       = this.active._eventQueue.dequeue();\n        if (event) {\n          // Process queued function, tick, and on to next event\n          event();\n          this.emit('tick', 0);\n          this.run();\n        } else if (this.expected > 0)\n          // We're waiting for some events to come along, don't know when,\n          // but they'll call run for us\n          this.emit('tick', 0);\n        else if (jsdomQueue.tail) {\n          jsdomQueue.resume();\n          this.run();\n        } else {\n          // All that's left are timers, and not even that if next == Infinity\n          const next = this.active._eventQueue.next;\n          if (isFinite(next))\n            this.emit('tick', next);\n          else\n            this.emit('idle');\n        }\n\n      } catch (error) {\n        this.emit('error', error);\n      }\n    });\n  }\n\n};\n\n"],"sourceRoot":"/source/"}