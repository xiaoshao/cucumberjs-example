// See [Web Storage](http://dev.w3.org/html5/webstorage/)
'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _core = require('babel-runtime/core-js')['default'];

var DOM = require('./dom');

// Implementation of the StorageEvent.

var StorageEvent = (function (_DOM$Event) {
  function StorageEvent(storage, url, key, oldValue, newValue) {
    _classCallCheck(this, StorageEvent);

    _DOM$Event.call(this, 'storage');
    this._storage = storage;
    this._url = url;
    this._key = key;
    this._oldValue = oldValue;
    this._newValue = newValue;
  }

  _inherits(StorageEvent, _DOM$Event);

  _createClass(StorageEvent, [{
    key: 'url',
    get: function () {
      return this._url;
    }
  }, {
    key: 'storageArea',
    get: function () {
      return this._storage;
    }
  }, {
    key: 'key',
    get: function () {
      return this._key;
    }
  }, {
    key: 'oldValue',
    get: function () {
      return this._oldValue;
    }
  }, {
    key: 'newValue',
    get: function () {
      return this._newValue;
    }
  }]);

  return StorageEvent;
})(DOM.Event);

// Storage area. The storage area is shared by multiple documents of the same
// origin. For session storage, they must also share the same browsing context.

var StorageArea = (function () {
  function StorageArea() {
    _classCallCheck(this, StorageArea);

    this._items = {};
    this._storages = [];
  }

  // Fire a storage event. Fire in all documents that share this storage area,
  // except for the source document.

  StorageArea.prototype._fire = function _fire(source, key, oldValue, newValue) {
    for (var _iterator = this._storages, _isArray = _core.Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _core.getIterator(_iterator);;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var storage = _ref[0];
      var _window = _ref[1];

      if (storage === source) continue;
      var _event = new StorageEvent(storage, _window.location.href, key, oldValue, newValue);
      _window.dispatchEvent(_event);
    }
  };

  // Get key by ordinal position.

  StorageArea.prototype.key = function key(index) {
    return _core.Object.keys(this._items)[index];
  };

  // Get value from key

  StorageArea.prototype.get = function get(key) {
    return this._items[key] || null;
  };

  // Set the value of a key. We also need the source storage (so we don't send
  // it a storage event).

  StorageArea.prototype.set = function set(source, key, value) {
    var oldValue = this._items[key];
    this._items[key] = value;
    this._fire(source, key, oldValue, value);
  };

  // Remove the value at the key. We also need source storage (see set above).

  StorageArea.prototype.remove = function remove(source, key) {
    var oldValue = this._items[key];
    delete this._items[key];
    this._fire(source, key, oldValue);
  };

  // Remove all values. We also need source storage (see set above).

  StorageArea.prototype.clear = function clear(source) {
    this._items = {};
    this._fire(source);
  };

  StorageArea.prototype.toString = function toString() {
    var _this3 = this;

    return _core.Object.keys(this._items).map(function (key) {
      return '' + key + ' = ' + _this3._items[key];
    }).join('\n');
  };

  // Associate local/sessionStorage and window with this storage area. Used when firing events.

  StorageArea.prototype.associate = function associate(storage, window) {
    this._storages.push([storage, window]);
  };

  _createClass(StorageArea, [{
    key: 'length',

    // Return number of key/value pairs.
    get: function () {
      return _core.Object.keys(this._items).length;
    }
  }, {
    key: 'pairs',
    get: function () {
      var _this4 = this;

      return _core.Object.keys(this._items).map(function (key) {
        return [key, _this4._items[key]];
      });
    }
  }]);

  return StorageArea;
})();

// Implementation of the Storage interface, used by local and session storage.

var Storage = (function () {
  function Storage(area) {
    _classCallCheck(this, Storage);

    this._area = area;
  }

  // ### storage.key(index) => String
  //
  // Returns the key at this position.

  Storage.prototype.key = function key(index) {
    return this._area.key(index);
  };

  // ### storage.getItem(key) => Object
  //
  // Returns item by key.

  Storage.prototype.getItem = function getItem(key) {
    return this._area.get(key.toString());
  };

  // ### storage.setItem(key, Object)
  //
  // Add item or change value of existing item.

  Storage.prototype.setItem = function setItem(key, value) {
    this._area.set(this, key.toString(), value);
  };

  // ### storage.removeItem(key)
  //
  // Remove item.

  Storage.prototype.removeItem = function removeItem(key) {
    this._area.remove(this, key.toString());
  };

  // ### storage.clear()
  //
  // Remove all items.

  Storage.prototype.clear = function clear() {
    this._area.clear(this);
  };

  // Dump to a string, useful for debugging.

  Storage.prototype.dump = function dump() {
    var output = arguments[0] === undefined ? process.stdout : arguments[0];

    return this._area.dump(output);
  };

  _createClass(Storage, [{
    key: 'length',

    // ### storage.length => Number
    //
    // Returns the number of key/value pairs in this storage.
    get: function () {
      return this._area.length;
    }
  }]);

  return Storage;
})();

// Combined local/session storage.

var Storages = (function () {
  function Storages() {
    _classCallCheck(this, Storages);

    this._locals = {};
    this._sessions = {};
  }

  // Return local Storage based on the document origin (hostname/port).

  Storages.prototype.local = function local(host) {
    if (!this._locals[host]) this._locals[host] = new StorageArea();
    return new Storage(this._locals[host]);
  };

  // Return session Storage based on the document origin (hostname/port).

  Storages.prototype.session = function session(host) {
    if (!this._sessions[host]) this._sessions[host] = new StorageArea();
    return new Storage(this._sessions[host]);
  };

  // Extend window with local/session storage support.

  Storages.prototype.extend = function extend(window) {
    var storages = this;
    window.StorageEvent = StorageEvent;
    _core.Object.defineProperties(window, {
      localStorage: {
        get: function get() {
          var document = this.document;

          if (!document._localStorage) document._localStorage = storages.local(document.location.host);
          return document._localStorage;
        }
      },

      sessionStorage: {
        get: function get() {
          var document = this.document;

          if (!document._sessionStorage) document._sessionStorage = storages.session(document.location.host);
          return document._sessionStorage;
        }
      }
    });
  };

  // Used to dump state to console (debuggin)

  Storages.prototype.dump = function dump() {
    var output = arguments[0] === undefined ? process.stdout : arguments[0];

    for (var _iterator2 = this._locals, _isArray2 = _core.Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _core.getIterator(_iterator2);;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var domain = _ref2;

      var area = this._locals[domain];
      output.write('' + domain + ' local:\n');
      for (var _iterator4 = area.pairs, _isArray4 = _core.Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _core.getIterator(_iterator4);;) {
        var _ref4;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref4 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref4 = _i4.value;
        }

        var _name = _ref4[0];
        var value = _ref4[1];

        output.write('  ' + _name + ' = ' + value + '\n');
      }
    }
    for (var _iterator3 = this._sessions, _isArray3 = _core.Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _core.getIterator(_iterator3);;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var domain = _ref3;

      var area = this._sessions[domain];
      output.push('' + domain + ' session:\n');
      for (var _iterator5 = area.pairs, _isArray5 = _core.Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _core.getIterator(_iterator5);;) {
        var _ref5;

        if (_isArray5) {
          if (_i5 >= _iterator5.length) break;
          _ref5 = _iterator5[_i5++];
        } else {
          _i5 = _iterator5.next();
          if (_i5.done) break;
          _ref5 = _i5.value;
        }

        var _name2 = _ref5[0];
        var value = _ref5[1];

        output.write('  ' + _name2 + ' = ' + value + '\n');
      }
    }
  };

  // browser.saveStorage uses this

  Storages.prototype.save = function save() {
    var serialized = ['# Saved on ' + new Date().toISOString()];
    for (var _iterator6 = this._locals, _isArray6 = _core.Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _core.getIterator(_iterator6);;) {
      var _ref6;

      if (_isArray6) {
        if (_i6 >= _iterator6.length) break;
        _ref6 = _iterator6[_i6++];
      } else {
        _i6 = _iterator6.next();
        if (_i6.done) break;
        _ref6 = _i6.value;
      }

      var domain = _ref6;

      var area = this._locals[domain];
      var pairs = area.pairs;
      if (pairs.length) {
        serialized.push('' + domain + ' local:');
        for (var _iterator8 = area.pairs, _isArray8 = _core.Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _core.getIterator(_iterator8);;) {
          var _ref8;

          if (_isArray8) {
            if (_i8 >= _iterator8.length) break;
            _ref8 = _iterator8[_i8++];
          } else {
            _i8 = _iterator8.next();
            if (_i8.done) break;
            _ref8 = _i8.value;
          }

          var _name3 = _ref8[0];
          var value = _ref8[1];

          serialized.push('  ' + escape(_name3) + ' = ' + escape(value));
        }
      }
    }
    for (var _iterator7 = this._sessions, _isArray7 = _core.Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _core.getIterator(_iterator7);;) {
      var _ref7;

      if (_isArray7) {
        if (_i7 >= _iterator7.length) break;
        _ref7 = _iterator7[_i7++];
      } else {
        _i7 = _iterator7.next();
        if (_i7.done) break;
        _ref7 = _i7.value;
      }

      var domain = _ref7;

      var area = this._sessions[domain];
      var pairs = area.pairs;
      if (pairs.length) {
        serialized.push('' + domain + ' session:');
        for (var _iterator9 = area.pairs, _isArray9 = _core.Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _core.getIterator(_iterator9);;) {
          var _ref9;

          if (_isArray9) {
            if (_i9 >= _iterator9.length) break;
            _ref9 = _iterator9[_i9++];
          } else {
            _i9 = _iterator9.next();
            if (_i9.done) break;
            _ref9 = _i9.value;
          }

          var _name4 = _ref9[0];
          var value = _ref9[1];

          serialized.push('  ' + escape(_name4) + ' = ' + escape(value));
        }
      }
    }
    return serialized.join('\n') + '\n';
  };

  // browser.loadStorage uses this

  Storages.prototype.load = function load(serialized) {
    var storage = null;
    for (var _iterator10 = serialized.split(/\n+/), _isArray10 = _core.Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _core.getIterator(_iterator10);;) {
      var _ref10;

      if (_isArray10) {
        if (_i10 >= _iterator10.length) break;
        _ref10 = _iterator10[_i10++];
      } else {
        _i10 = _iterator10.next();
        if (_i10.done) break;
        _ref10 = _i10.value;
      }

      var item = _ref10;

      if (item[0] === '#' || item === '') continue;
      if (item[0] === ' ') {
        var _item$split = item.split('=');

        var key = _item$split[0];
        var value = _item$split[1];

        if (storage) storage.setItem(unescape(key.trim()), unescape(value.trim()));else throw new Error('Must specify storage type using local: or session:');
      } else {
        var _item$split2 = item.split(' ');

        var domain = _item$split2[0];
        var type = _item$split2[1];

        if (type === 'local:') storage = this.local(domain);else if (type === 'session:') storage = this.session(domain);else throw new Error('Unkown storage type ' + type);
      }
    }
  };

  return Storages;
})();

module.exports = Storages;
//# sourceMappingURL=storage.js.map